#pragma once

#include "atomics/atomic_base"

namespace jang {

template <typename T>
struct atomic : public atomic_base<T> {
public:
protected:
private:
public:
	atomic() noexcept = default;
	constexpr atomic(T value) noexcept : atomic_base<T>(value) {}
	atomic(const atomic&) = default;
	atomic(atomic&&) = default;
	~atomic() = default;

	atomic& operator=(const atomic&) = default;

	T operator=(T value) volatile noexcept { 
		atomic_base<T>::store(value);
		return value;
	}

	T operator=(T value) noexcept { 
		atomic_base<T>::store(value);
		return value;
	}

protected:
private: 
};

template <typename T>
struct atomic<T*> : public atomic_base<T*> {
public:
protected:
private:
public:
	atomic() noexcept = default;
	atomic(T* value) noexcept : atomic_base<T*>(value) {}
	atomic(const atomic&) = default;
	atomic(atomic&&) = default;
	~atomic() = default;

	atomic& operator=(const atomic&) = default;

	T* operator=(T* value) volatile noexcept { 
		atomic_base<T*>::store(value);
		return value;
	}

	T* operator=(T* value) noexcept { 
		atomic_base<T*>::store(value);
		return value;
	}

	T* fetch_add(pointer_difference_type operand, memory_order order = memory_order::sequential_consistency) volatile noexcept { return atomic_fetch_add(&this->_atomic, operand, order); }
    T* fetch_add(pointer_difference_type operand, memory_order order = memory_order::sequential_consistency) noexcept { return atomic_fetch_add(&this->_atomic, operand, order); }
  
    T* fetch_sub(pointer_difference_type operand, memory_order order = memory_order::sequential_consistency) volatile noexcept { return atomic_fetch_sub(&this->_atomic, operand, order); }
    T* fetch_sub(pointer_difference_type operand, memory_order order = memory_order::sequential_consistency) noexcept { return atomic_fetch_sub(&this->_atomic, operand, order); }

  
    T* operator++(int) volatile noexcept { return fetch_add(1); }  
    T* operator++(int) noexcept { return fetch_add(1); }
  
    T* operator--(int) volatile noexcept { return fetch_sub(1); }  
    T* operator--(int) noexcept { return fetch_sub(1); }
  
    T* operator++() volatile noexcept { return fetch_add(1) + 1; }  
    T* operator++() noexcept { return fetch_add(1) + 1; }
  
    T* operator--() volatile noexcept { return fetch_sub(1) - 1; }  
    T* operator--() noexcept { return fetch_sub(1) - 1; }
  
    T* operator+=(pointer_difference_type operand) volatile noexcept { return fetch_add(operand) + operand; }  
    T* operator+=(pointer_difference_type operand) noexcept { return fetch_add(operand) + operand; }
  
    T* operator-=(pointer_difference_type operand) volatile noexcept { return fetch_sub(operand) - operand; }  
    T* operator-=(pointer_difference_type operand) noexcept { return fetch_sub(operand) - operand; }

protected:
private: 
};

template <class T>
inline bool atomic_is_lock_free(const volatile atomic<T>* atomic) noexcept { return atomic->is_lock_free(); }

template <class T>
inline bool atomic_is_lock_free(const atomic<T>* atomic) noexcept { return atomic->is_lock_free(); }


template <class T>
inline void atomic_init(volatile atomic<T>* atomic, T value) noexcept { atomic_init(&atomic->_atomic, value); }

template <class T>
inline void atomic_init(atomic<T>* atomic, T value) noexcept { atomic_init(&atomic->_atomic, value); }


template <class T>
inline void atomic_store(volatile atomic<T>* atomic, T value) noexcept { atomic->store(value); }

template <class T>
inline void atomic_store(atomic<T>* atomic, T value) noexcept { atomic->store(value); }


template <class T>
inline void atomic_store_explicit(volatile atomic<T>* atomic, T value, memory_order order) noexcept { atomic->store(value, order); }

template <class T>
inline void atomic_store_explicit(atomic<T>* atomic, T value, memory_order order) noexcept { atomic->store(value, order); }


template <class T>
inline T atomic_load(const volatile atomic<T>* atomic) noexcept { return atomic->load(); }

template <class T>
inline T atomic_load(const atomic<T>* atomic) noexcept { return atomic->load(); }


template <class T>
inline T atomic_load_explicit(const volatile atomic<T>* atomic, memory_order order) noexcept { return atomic->load(order); }

template <class T>
inline T atomic_load_explicit(const atomic<T>* atomic, memory_order order) noexcept { return atomic->load(order); }


template <class T>
inline T atomic_exchange(volatile atomic<T>* atomic, T value) noexcept { return atomic->exchange(value); }

template <class T>
inline T atomic_exchange(atomic<T>* atomic, T value) noexcept { return atomic->exchange(value); }


template <class T>
inline T atomic_exchange_explicit(volatile atomic<T>* atomic, T value, memory_order order) noexcept { return atomic->exchange(value, order); }

template <class T>
inline T atomic_exchange_explicit(atomic<T>* atomic, T value, memory_order order) noexcept { return atomic->exchange(value, order); }


template <class T>
inline bool atomic_compare_exchange_weak(volatile atomic<T>* atomic, T* expected, T value) noexcept { return atomic->compare_exchange_weak(*expected, value); }

template <class T>
inline bool atomic_compare_exchange_weak(atomic<T>* atomic, T* expected, T value) noexcept { return atomic->compare_exchange_weak(*expected, value); }


template <class T>
inline bool atomic_compare_exchange_strong(volatile atomic<T>* atomic, T* expected, T value) noexcept { return atomic->compare_exchange_strong(*expected, value); }

template <class T>
inline bool atomic_compare_exchange_strong(atomic<T>* atomic, T* expected, T value) noexcept { return atomic->compare_exchange_strong(*expected, value); }


template <class T>
inline bool atomic_compare_exchange_weak_explicit(volatile atomic<T>* atomic, T* expected, T value, memory_order success, memory_order failure) noexcept { return atomic->compare_exchange_weak(*expected, value, success, failure); }

template <class T>
inline bool atomic_compare_exchange_weak_explicit(atomic<T>* atomic, T* expected, T value, memory_order success, memory_order failure) noexcept { return atomic->compare_exchange_weak(*expected, value, success, failure); }


template <class T>
inline bool atomic_compare_exchange_strong_explicit(volatile atomic<T>* atomic, T* expected, T value, memory_order success, memory_order failure) noexcept { return atomic->compare_exchange_strong(*expected, value, success, failure); }

template <class T>
inline bool atomic_compare_exchange_strong_explicit(atomic<T>* atomic, T* expected, T value, memory_order success, memory_order failure) noexcept { return atomic->compare_exchange_strong(*expected, value, success, failure); }


template <class T>
inline enable_if_type<is_integral_value<T> && !is_same_value<T, bool>, T> atomic_fetch_add(volatile atomic<T>* atomic, T atomicp) noexcept { return atomic->fetch_add(atomicp); }

template <class T>
inline enable_if_type<is_integral_value<T> && !is_same_value<T, bool>, T> atomic_fetch_add(atomic<T>* atomic, T atomicp) noexcept { return atomic->fetch_add(atomicp); }

template <class T>
inline T* atomic_fetch_add(volatile atomic<T*>* atomic, pointer_difference_type atomicp) noexcept { return atomic->fetch_add(atomicp); }

template <class T>
inline T* atomic_fetch_add(atomic<T*>* atomic, pointer_difference_type atomicp) noexcept { return atomic->fetch_add(atomicp); }


template <class T>
inline enable_if_type<is_integral_value<T> && !is_same_value<T, bool>, T> atomic_fetch_add_explicit(volatile atomic<T>* atomic, T atomicp, memory_order order) noexcept { return atomic->fetch_add(atomicp, order); }

template <class T>
inline enable_if_type<is_integral_value<T> && !is_same_value<T, bool>, T> atomic_fetch_add_explicit(atomic<T>* atomic, T atomicp, memory_order order) noexcept { return atomic->fetch_add(atomicp, order); }

template <class T>
inline T* atomic_fetch_add_explicit(volatile atomic<T*>* atomic, pointer_difference_type atomicp, memory_order order) noexcept { return atomic->fetch_add(atomicp, order); }

template <class T>
inline T* atomic_fetch_add_explicit(atomic<T*>* atomic, pointer_difference_type atomicp, memory_order order) noexcept { return atomic->fetch_add(atomicp, order); }


template <class T>
inline enable_if_type<is_integral_value<T> && !is_same_value<T, bool>, T> atomic_fetch_sub(volatile atomic<T>* atomic, T atomicp) noexcept { return atomic->fetch_sub(atomicp); }

template <class T>
inline enable_if_type<is_integral_value<T> && !is_same_value<T, bool>, T> atomic_fetch_sub(atomic<T>* atomic, T atomicp) noexcept { return atomic->fetch_sub(atomicp); }

template <class T>
inline T* atomic_fetch_sub(volatile atomic<T*>* atomic, pointer_difference_type atomicp) noexcept { return atomic->fetch_sub(atomicp); }

template <class T>
inline T* atomic_fetch_sub(atomic<T*>* atomic, pointer_difference_type atomicp) noexcept { return atomic->fetch_sub(atomicp); }


template <class T>
inline enable_if_type<is_integral_value<T> && !is_same_value<T, bool>, T> atomic_fetch_sub_explicit(volatile atomic<T>* atomic, T atomicp, memory_order order) noexcept { return atomic->fetch_sub(atomicp, order); }

template <class T>
inline enable_if_type<is_integral_value<T> && !is_same_value<T, bool>, T> atomic_fetch_sub_explicit(atomic<T>* atomic, T atomicp, memory_order order) noexcept { return atomic->fetch_sub(atomicp, order); }

template <class T>
inline T* atomic_fetch_sub_explicit(volatile atomic<T*>* atomic, pointer_difference_type atomicp, memory_order order) noexcept { return atomic->fetch_sub(atomicp, order); }

template <class T>
inline T* atomic_fetch_sub_explicit(atomic<T*>* atomic, pointer_difference_type atomicp, memory_order order) noexcept { return atomic->fetch_sub(atomicp, order); }


template <class T>
inline enable_if_type<is_integral_value<T> && !is_same_value<T, bool>, T> atomic_fetch_and(volatile atomic<T>* atomic, T atomicp) noexcept { return atomic->fetch_and(atomicp); }

template <class T>
inline enable_if_type<is_integral_value<T> && !is_same_value<T, bool>, T> atomic_fetch_and(atomic<T>* atomic, T atomicp) noexcept { return atomic->fetch_and(atomicp); }


template <class T>
inline enable_if_type<is_integral_value<T> && !is_same_value<T, bool>, T> atomic_fetch_and_explicit(volatile atomic<T>* atomic, T atomicp, memory_order order) noexcept { return atomic->fetch_and(atomicp, order); }

template <class T>
inline enable_if_type<is_integral_value<T> && !is_same_value<T, bool>, T> atomic_fetch_and_explicit(atomic<T>* atomic, T atomicp, memory_order order) noexcept { return atomic->fetch_and(atomicp, order); }


template <class T>
inline enable_if_type<is_integral_value<T> && !is_same_value<T, bool>, T> atomic_fetch_or(volatile atomic<T>* atomic, T atomicp) noexcept { return atomic->fetch_or(atomicp); }

template <class T>
inline enable_if_type<is_integral_value<T> && !is_same_value<T, bool>, T> atomic_fetch_or(atomic<T>* atomic, T atomicp) noexcept { return atomic->fetch_or(atomicp); }


template <class T>
inline enable_if_type<is_integral_value<T> && !is_same_value<T, bool>, T> atomic_fetch_or_explicit(volatile atomic<T>* atomic, T atomicp, memory_order order) noexcept { return atomic->fetch_or(atomicp, order); }

template <class T>
inline enable_if_type<is_integral_value<T> && !is_same_value<T, bool>, T> atomic_fetch_or_explicit(atomic<T>* atomic, T atomicp, memory_order order) noexcept { return atomic->fetch_or(atomicp, order); }


template <class T>
inline enable_if_type<is_integral_value<T> && !is_same_value<T, bool>, T> atomic_fetch_xor(volatile atomic<T>* atomic, T atomicp) noexcept { return atomic->fetch_xor(atomicp); }

template <class T>
inline enable_if_type<is_integral_value<T> && !is_same_value<T, bool>, T> atomic_fetch_xor(atomic<T>* atomic, T atomicp) noexcept { return atomic->fetch_xor(atomicp); }


template <class T>
inline enable_if_type<is_integral_value<T> && !is_same_value<T, bool>, T> atomic_fetch_xor_explicit(volatile atomic<T>* atomic, T atomicp, memory_order order) noexcept { return atomic->fetch_xor(atomicp, order); }

template <class T>
inline enable_if_type<is_integral_value<T> && !is_same_value<T, bool>, T> atomic_fetch_xor_explicit(atomic<T>* atomic, T atomicp, memory_order order) noexcept { return atomic->fetch_xor(atomicp, order); }

struct atomic_flag {
public:
protected:
private:
    atomic_type(bool) _atomic;
public:
    atomic_flag() = default;
    constexpr atomic_flag(bool value) noexcept : _atomic(value) {}
    atomic_flag(const atomic_flag&) = delete;
    atomic_flag(atomic_flag&&) = delete;
    ~atomic_flag() = default;

    atomic_flag& operator=(const atomic_flag&) = delete;
    atomic_flag& operator=(const atomic_flag&) volatile = delete;

    bool test_and_set(memory_order order = memory_order::sequential_consistency) volatile noexcept { return atomic_exchange(&_atomic, true, order); }
    bool test_and_set(memory_order order = memory_order::sequential_consistency) noexcept { return atomic_exchange(&_atomic, true, order); }
    
    void clear(memory_order order = memory_order::sequential_consistency) volatile noexcept { atomic_store(&_atomic, false, order); }
    void clear(memory_order order = memory_order::sequential_consistency) noexcept { atomic_store(&_atomic, false, order); }

    inline bool atomic_flag_test_and_set(volatile atomic_flag* atomic) noexcept { return atomic->test_and_set(); }
    inline bool atomic_flag_test_and_set(atomic_flag* atomic) noexcept { return atomic->test_and_set(); }

    inline bool atomic_flag_test_and_set_explicit(volatile atomic_flag* atomic, memory_order order) noexcept { return atomic->test_and_set(order); }
    inline bool atomic_flag_test_and_set_explicit(atomic_flag* atomic, memory_order order) noexcept { return atomic->test_and_set(order); }

    inline void atomic_flag_clear(volatile atomic_flag* atomic) noexcept { atomic->clear(); }
    inline void atomic_flag_clear(atomic_flag* atomic) noexcept { atomic->clear(); }

    inline void atomic_flag_clear_explicit(volatile atomic_flag* atomic, memory_order order) noexcept { atomic->clear(order); }
    inline void atomic_flag_clear_explicit(atomic_flag* atomic, memory_order order) noexcept { atomic->clear(order); }

    inline void atomic_thread_fence(memory_order order) noexcept { atomic_thread_fence(order); }
    inline void atomic_signal_fence(memory_order order) noexcept { atomic_signal_fence(order); }


protected:
private:
};

typedef atomic<char>					       atomic_char_type;
typedef atomic<signed char> 			       atomic_signed_char_type;
typedef atomic<unsigned char> 			       atomic_unsigned_char_type;
typedef atomic<short> 					       atomic_short_type;
typedef atomic<unsigned short> 			       atomic_unsigned_short_type;
typedef atomic<int> 					       atomic_int_type;
typedef atomic<unsigned int> 			       atomic_unsigned_int_type;
typedef atomic<long> 					       atomic_long_type;
typedef atomic<unsigned long> 			       atomic_unsigned_long_type;
typedef atomic<long long> 				       atomic_long_long_type;
typedef atomic<unsigned long long> 		       atomic_unsigned_long_long_type;
typedef atomic<wide_char_type> 			       atomic_wide_char_type;
typedef atomic<char_16_type> 			       atomic_char_16_type;
typedef atomic<char_32_type> 			       atomic_char_32_type;

typedef atomic<int_least_8_type>     	       atomic_int_least_8_type;
typedef atomic<unsigned_int_least_8_type>      atomic_unsigned_int_least_8_type;
typedef atomic<int_least_16_type>      		   atomic_int_least_16_type;
typedef atomic<unsigned_int_least_16_type>     atomic_unsigned_int_least_16_type;
typedef atomic<int_least_32_type>              atomic_int_least_32_type;
typedef atomic<unsigned_int_least_32_type>     atomic_unsigned_int_least_32_type;
typedef atomic<int_least_64_type>      		   atomic_int_least_64_type;
typedef atomic<unsigned_int_least_64_type>     atomic_unsigned_int_least_64_type;

typedef atomic<int_fast_8_type>      	       atomic_int_fast_8_type;
typedef atomic<unsigned_int_fast_8_type>       atomic_unsigned_int_fast_8_type;
typedef atomic<int_fast_16_type>      		   atomic_int_fast_16_type;
typedef atomic<unsigned_int_fast_16_type>      atomic_unsigned_int_fast_16_type;
typedef atomic<int_fast_32_type>        	   atomic_int_fast_32_type;
typedef atomic<unsigned_int_fast_32_type>      atomic_unsigned_int_fast_32_type;
typedef atomic<int_fast_64_type>      		   atomic_int_fast_64_type;
typedef atomic<unsigned_int_fast_64_type>      atomic_unsigned_int_fast_64_type;

typedef atomic<int_pointer_type>      		   atomic_int_pointer_type;
typedef atomic<unsigned_int_pointer_type>      atomic_unsigned_int_pointer_type;

typedef atomic<size_type>       			   atomic_size_type;

typedef atomic<int_max_type>     		       atomic_int_max_type;
typedef atomic<unsigned_int_max_type>          atomic_unsigned_int_max_type;

typedef atomic<pointer_difference_type>        atomic_pointer_difference_type;


template <typename T>
inline T kill_dependency(T t) { T result(t); return result; }

inline memory_order __calculate_memory_order(memory_order mo) { return (mo == memory_order::acquire_release ? memory_order::acquire : mo == memory_order::release ? memory_order::relaxed : mo); }

#define ATOMIC_FLAG_INIT {false}
#define ATOMIC_VAR_INIT(__v) {__v}

#define ATOMIC_BOOL_LOCK_FREE      __GCC_ATOMIC_BOOL_LOCK_FREE
#define ATOMIC_CHAR_LOCK_FREE      __GCC_ATOMIC_CHAR_LOCK_FREE
#define ATOMIC_CHAR16_T_LOCK_FREE  __GCC_ATOMIC_CHAR16_T_LOCK_FREE
#define ATOMIC_CHAR32_T_LOCK_FREE  __GCC_ATOMIC_CHAR32_T_LOCK_FREE
#define ATOMIC_WCHAR_T_LOCK_FREE   __GCC_ATOMIC_WCHAR_T_LOCK_FREE
#define ATOMIC_SHORT_LOCK_FREE     __GCC_ATOMIC_SHORT_LOCK_FREE
#define ATOMIC_INT_LOCK_FREE       __GCC_ATOMIC_INT_LOCK_FREE
#define ATOMIC_LONG_LOCK_FREE      __GCC_ATOMIC_LONG_LOCK_FREE
#define ATOMIC_LLONG_LOCK_FREE     __GCC_ATOMIC_LLONG_LOCK_FREE
#define ATOMIC_POINTER_LOCK_FREE   __GCC_ATOMIC_POINTER_LOCK_FREE

 }
