#pragma once

#include "type_traits.h"
#include "compare.h"

namespace jang {



class mergesort {
public:
	template<typename _It, typename _Comparator = less<typename std::iterator_traits<_It>::value_type>>
	void operator()(_It begin, _It end) {
		if (std::distance(begin, end) < 2) {
			return;
		}

		auto mid = std::next(begin, std::distance(begin, end) / 2);
		operator()(begin, mid);
		operator()(mid, end);
		auto&& v = _merge(begin, mid, end);
		std::move(v.begin(), v.end(), begin);
	}
private:

	template<typename _It, typename _Comparator = less<typename std::iterator_traits<_It>::value_type>>
	std::vector<typename std::iterator_traits<_It>::value_type> _merge(_It begin, _It mid, _It end) {
		std::vector<typename std::iterator_traits<_It>::value_type> result;

		_Comparator _comparator;

		auto lb = begin, le = mid, rb = mid, re = end;
		while (lb != le && rb != re) {
			if (_comparator(*lb, *rb)) {
				result.push_back(*lb);
				std::advance(lb, 1);
			} else {
				result.push_back(*rb);
				std::advance(rb, 1);
			}
		}

		result.insert(result.end(), lb, le);
		result.insert(result.end(), rb, re);

		return std::move(result);
	}
};

class quicksort {
public:

	template<typename _It, typename _Comparator = less<typename std::iterator_traits<_It>::value_type>>
	void operator()(_It begin, _It end) {
		if (std::distance(begin, end) < 2) {
			return;
		}

		auto p = partition(begin, end);
		operator()(begin, p);
		operator()(std::next(p, 1), end);
	}

private:

	template<typename _It, typename _Comparator = less<typename std::iterator_traits<_It>::value_type>>
	_It partition(_It begin, _It end) {
		auto left = begin, right = end;
		auto p = pivot(begin, end);
		auto val = *p;
		_Comparator _comparator;

		std::advance(right, -1);
		std::swap(*p, *right);

		auto q = left;
		while (left != right) {
			if (_comparator(*left, val)) {
				std::swap(*q, *left);
				std::advance(q, 1);
			}
			std::advance(left, 1);
		}

		std::swap(*right, *q);
		return q;
	}

	template<typename _It>
	_It pivot(_It begin, _It end) {
		return std::next(begin, std::distance(begin, end) / 2);
	}
};


template<typename _Policy>
struct sort : public _Policy {
	typedef _Policy policy;

	template<typename _It, typename _Comparator = less<typename std::iterator_traits<_It>::value_type>>
	void operator()(_It begin, _It end) { _Policy::operator()(begin, end); }
};

}
