#pragma once

#include "type_traits"
#include "compare"
#include "iterator"
#include "container"

namespace jang {

template<typename Iterator, template <typename> typename Comparator = less>
class merge {
public:
	typedef Iterator iterator_type;
	typedef typename iterator_traits<iterator_type>::value_type type;
	typedef Comparator<type> comparator_type;
protected:
private:
public:
	void operator()(iterator_type begin, iterator_type end) {
		if (distance(begin, end) < 2) {
			return;
		}

		auto mid = next(begin, distance(begin, end) / 2);
		operator()(begin, mid);
		operator()(mid, end);
		auto&& v = _merge(begin, mid, end);
		move(v.begin(), v.end(), begin);
	}
protected:
private:
	template <typename T> class sequence_container;
	sequence_container<type> _merge(iterator_type begin, iterator_type mid, iterator_type end) {
		sequence_container<type> result;

		comparator_type comparator;

		auto lb = begin, le = mid, rb = mid, re = end;
		while (lb != le && rb != re) {
			if (comparator(*lb, *rb)) {
				result.push_back(*lb);
				advance(lb, 1);
			} else {
				result.push_back(*rb);
				advance(rb, 1);
			}
		}

		result.insert(result.end(), lb, le);
		result.insert(result.end(), rb, re);

		return move(result);
	}
};

template<typename Iterator, template <typename> typename Comparator = less>
class quick {
public:
	typedef Iterator iterator_type;
	typedef typename iterator_traits<iterator_type>::value_type type;
	typedef Comparator<type> comparator_type;
protected:
private:
public:

	void operator()(iterator_type begin, iterator_type end) {
		if (distance(begin, end) < 2) {
			return;
		}

		auto p = _partition(begin, end);
		operator()(begin, p);
		operator()(next(p, 1), end);
	}

protected:
private:

	iterator_type _partition(iterator_type begin, iterator_type end) {
		auto left = begin, right = end;
		auto p = pivot(begin, end);
		auto val = *p;
		comparator_type comparator;

		advance(right, -1);
		swap(*p, *right);

		auto q = left;
		while (left != right) {
			if (comparator(*left, val)) {
				swap(*q, *left);
				advance(q, 1);
			}
			advance(left, 1);
		}

		swap(*right, *q);
		return q;
	}

	iterator_type _pivot(iterator_type begin, iterator_type end) { return next(begin, distance(begin, end) / 2); }
};


template <typename Iterator, template <typename> typename Comparator, template <typename, template<typename> typename> typename Policy = quick>
struct sorter : public Policy<Iterator, Comparator> {
	typedef Policy<Iterator, Comparator> policy_type;

	void operator()(Iterator begin, Iterator end) { policy_type::operator()(begin, end); }
};

template <typename Iterator, template <typename> typename Comparator = less, template <typename, template <typename> typename> typename Policy = quick>
void sort(Iterator begin, Iterator end) { Policy<Iterator, Comparator>::operator()(begin,end); }

}
