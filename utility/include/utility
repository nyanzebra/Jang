#pragma once

#include "type_traits_categories/references"
#include "type_traits_categories/primary_type_categories"
#include "iterator"
#include "utilities/declval"

namespace jang {

template <typename T>
constexpr remove_reference_type<T>&& move(T&& arg) { return static_cast<remove_reference_type<T>&&>(arg); }

template <typename InputIterator, typename OutputIterator>
OutputIterator move(InputIterator first, InputIterator last, OutputIterator destination) {
	while (first != last) *destination++ = move(*first++);
	return destination;
}

template <typename T>
constexpr T&& forward(remove_reference_type<T>&& arg) {
	static_assert(!is_lvalue_reference_value<T>, "Cannot forward an rvalue as an lvalue");
	return static_cast<T&&>(arg);
}

template <typename T>
constexpr T&& forward(typename remove_reference<T>::type& arg) { return static_cast<T&&>(arg); }

template <typename InputIterator, typename OutputIterator>
OutputIterator copy(InputIterator first, InputIterator last, OutputIterator destination) {
	while (first != last) *destination++ = *first++;
	return destination;
}

template <size_type N> size_type system_architecture_determination_template() { return 0_bytes_type;}

template <> size_type system_architecture_determination_template<1>() { return 1_bytes_type; }
template <> size_type system_architecture_determination_template<2>() { return 2_bytes_type; }
template <> size_type system_architecture_determination_template<4>() { return 4_bytes_type; }
template <> size_type system_architecture_determination_template<8>() {return 8_bytes_type; }
template <> size_type system_architecture_determination_template<16>() { return 16_bytes_type; }

size_type system_architecture() { return system_architecture_determination_template<sizeof(size_type)>() * 8; }


template <typename First, typename Second>
class pair {
public:
	typedef First first_type;
	typedef Second second_type;
	first_type first;
	second_type second;
protected:
private:
public:
	pair(const first_type& first, const second_type& second) : first(first), second(second) {}
	pair(first_type&& first, second_type&& second) : first(move(first)), second(move(second)) {}
	pair(const pair& other) : first(other.first), second(other.second) {}
	pair(pair&& other) : first(move(other.first)), second(move(other.second)) {}
	~pair() {}
protected:
private:
};

template <typename T>
void swap(T& a, T& b) { auto c = a; a = b; b = c; }

template <typename Iterator>
void iterator_swap(Iterator a, Iterator b) { swap(*a, *b); }

template <typename InputForwardIterator, typename OutputForwardIterator>
OutputForwardIterator swap_ranges(InputForwardIterator input_first, InputForwardIterator input_last, OutputForwardIterator ouput_first) {
	while (input_first != input_last) iterator_swap(input_first, ouput_first);
	return ouput_first;
}

template <typename T, size_type N>
void swap(T (&a)[N], T(&b)[N]) { swap_ranges(a, a + N, b); }

template <typename T, typename U>
constexpr bool will_overflow(const T& t, const U& u) { return (t + (T)u < 0 || t + (T)u < t || (U)(t + (T)u) < u); }

template <typename T, typename U>
constexpr bool will_overflow(T&& t, U&& u) { return (forward(t) + (T)forward(u) < 0 || forward(t) + (T)forward(u) < t || (U)(forward(t) + (T)forward(u)) < u); }

}
