#pragma once

#include "vector"

#include "type_traits"

namespace jang {


template <typename T>
class node {
public:

protected:
	T _value;

private:
public:
	node(const T& val) : _value(val) {}
	node(T&& val) : _value(move(val)) {}
	node(const node& other) : _value(other._value) {}
	node(node&& other) : _value(move(other._value)) {}
	virtual ~node() {
		if (is_pointer<T>::_value) {
			delete _value;
		}
	}

	node& operator=(const node& other) {
		_value = other._value;
		return *this;
	}
protected:
private:
};

template <typename T>
class forward_node : public node<T> {
public:
protected:
	forward_node* _right;
private:
public:
	forward_node(const T&) = default;
	forward_node(T&&) = default;
	forward_node(const forward_node& other) : node<T>(other), _right(other._right) {}
	forward_node(forward_node&& other) : node<T>(move(other)), _right(move(other._right)) {}
	virtual ~forward_node() {
		if (_right != nullptr) {
			delete _right;
		}
	}

	forward_node& operator=(const forward_node& other) {
		this->_value = other._value;
		_right = other._right;
		return *this;
	}
protected:
private:
};

template <typename T>
class bidirectional_node : public forward_node<T> {
public:
protected:
	bidirectional_node* _left;
private:
public:
	bidirectional_node(const T&) = default;
	bidirectional_node(T&&) = default;
	bidirectional_node(const bidirectional_node& other) : forward_node<T>(other), _left(other._left) {}
	bidirectional_node(bidirectional_node&& other) : forward_node<T>(move(other)), _left(move(other._left)) {}
	virtual ~bidirectional_node() {
		if (_left != nullptr) {
			delete _left;
		}
	}

	bidirectional_node& operator=(const bidirectional_node& other) {
		this->_value = other._value;
		_left = other._left;
		this->_right = other._right;
		return *this;
	}
protected:
private:
};

template <typename T>
struct binary_tree_node : public bidirectional_node<T> {
public:
protected:
	const binary_tree_node* _parent;
private:
public:
	binary_tree_node(const T&) = default;
	binary_tree_node(T&&) = default;
	binary_tree_node(const binary_tree_node& other) : bidirectional_node<T>(other), _parent(other._parent) {}
	binary_tree_node(binary_tree_node&& other) : bidirectional_node<T>(move(other)), _parent(move(other._parent)) {}
	~binary_tree_node() {
		if (_parent != nullptr) {
			delete _parent;
		}
	}

	binary_tree_node& operator=(const binary_tree_node& other) {
		this->_value = other._value;
		this->_left = other._left;
		this->_right = other._right;
		_parent = other._parent;
		return *this;
	}
protected:
private:
};

template <typename T, typename Allocator = allocator<T>>
class graph_node : public node<T> {
public:
protected:
private:
	graph_node* _neighbours;
public:
	graph_node(const T& val) = default;
	graph_node(T&& val) = default;
	graph_node(const graph_node& other) : node<T>(other), _neighbours(other._neighbours) {}
	graph_node(graph_node&& other) : node<T>(move(other)), _neighbours(move(other._neighbours)) {}
	virtual ~graph_node() {
		for (auto it = _neighbours.begin(); it != _neighbours.end(); ++it) {
			if (*it != nullptr) {
				delete *it;
			}
		}
	}
protected:
private:
};

template <typename T, typename Allocator>
class tree_node : public graph_node<T, Allocator> {
public:
protected:
	const tree_node* _parent;
private:
public:
	tree_node(const T&) = default;
	tree_node(T&&) = default;
	tree_node(const tree_node& other) : graph_node<T, Allocator>(other._value), _parent(other._parent){}
	tree_node(tree_node&& other) : graph_node<T, Allocator>(move(other._value)), _parent(move(other._parent)) {}
	~tree_node() { 
		if (_parent != nullptr) {
			delete _parent;
		}
	}

	tree_node& operator=(const tree_node& other) { 
		this->_value = other._value;
		_parent = other._parent;
		this->_neighbours = other._neighbours; 
		return *this;
	}
protected:
private:
};




}
