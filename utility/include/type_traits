#pragma once

#include "definitions"
#include "types"
#include "algorithm"

namespace jang {

#ifndef DECLVAL
#define DECLVAL

template <typename T>
struct add_rvalue_reference;

template <typename T>
typename add_rvalue_reference<T>::type declval();

#endif

//==========================================================
// HEADER A
//==========================================================

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Header B
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

//----------------------------------------------------------
// header c
//----------------------------------------------------------

//==========================================================
// TYPE TRAITS 
//==========================================================
// http://en.cppreference.com/w/cpp/types

namespace {

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Helper Classes
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

namespace {

template <typename T, T v>
struct integral_constant {
	typedef T value_type;
	typedef const T const_value_type;

	typedef T& reference_type;
	typedef const T& const_reference_type;

	typedef T&& universal_type;

	typedef T* pointer_type;
	typedef const T* const_pointer_type;
	typedef T* const pointer_const_type;
	typedef const T* const const_pointer_const_type;

	static constexpr value_type value = v;

	typedef integral_constant type;
	constexpr operator typename value_type() const noexcept { return value; }
	constexpr typename value_type operator()() const noexcept { return value; }
};

template <bool B>
using bool_constant = integral_constant<bool, B>;

using true_type = bool_constant<true>;

using false_type = bool_constant<false>;

}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Type Properties
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

namespace {

//----------------------------------------------------------
// primary type categories
//----------------------------------------------------------

namespace {

template <typename T>
struct is_void : public false_type {};

template <>
struct is_void<void> : public true_type {};


template <typename T>
constexpr bool is_void_v = is_void<T>::value;


template <typename T>
struct is_null_pointer : public false_type {};

template <>
struct is_null_pointer<nullptr_type> : public true_type {};


template <typename T>
struct is_integral : public false_type {};

template <>
struct is_integral<bool> : public true_type {};

template <>
struct is_integral<char> : public true_type {};

template <>
struct is_integral<char16_t> : public true_type {};

template <>
struct is_integral<char32_t> : public true_type {};

template <>
struct is_integral<wchar_t> : public true_type {};

template <>
struct is_integral<short> : public true_type {};

template <>
struct is_integral<int> : public true_type {};

template <>
struct is_integral<long> : public true_type {};

template <>
struct is_integral<long long> : public true_type {};


template <typename T>
struct is_floating_point : public false_type {};

template <>
struct is_floating_point<float> : public true_type {};

template <>
struct is_floating_point<double> : public true_type {};

template <>
struct is_floating_point<long double> : public true_type {};


template <typename T>
struct is_array : public false_type {};

template <typename T>
struct is_array<T[]> : public true_type {};

template <typename T, size_type N>
struct is_array<T[N]> : public true_type {};


template <typename T>
struct is_enum : public bool_constant<__is_enum(T)> {};


template <typename T>
struct is_union : public bool_constant<__is_union(T)> {};


template <typename T>
struct is_class : public bool_constant<__is_class(T)> {};


template <typename T>
struct is_function : public false_type {};

template <typename T, typename... Args>
struct is_function<T(Args...)> : public true_type {};

template <typename T, typename... Args>
struct is_function<T(Args...)const> : public true_type {};

template <typename T, typename... Args>
struct is_function<T(Args...)volatile> : public true_type {};

template <typename T, typename... Args>
struct is_function<T(Args...)const volatile> : public true_type {};

template <typename T, typename... Args>
struct is_function<T(Args...)&> : public true_type {};

template <typename T, typename... Args>
struct is_function<T(Args...)const &> : public true_type {};

template <typename T, typename... Args>
struct is_function<T(Args...)volatile &> : public true_type {};

template <typename T, typename... Args>
struct is_function<T(Args...)const volatile &> : public true_type {};

template <typename T, typename... Args>
struct is_function<T(Args...) && > : public true_type {};

template <typename T, typename... Args>
struct is_function<T(Args...)const &&> : public true_type {};

template <typename T, typename... Args>
struct is_function<T(Args...)volatile &&> : public true_type {};

template <typename T, typename... Args>
struct is_function<T(Args...)const volatile &&> : public true_type {};

template <typename T, typename... Args>
struct is_function<T(Args..., ...)> : public true_type {};

template <typename T, typename... Args>
struct is_function<T(Args..., ...)const> : public true_type {};

template <typename T, typename... Args>
struct is_function<T(Args..., ...)volatile> : public true_type {};

template <typename T, typename... Args>
struct is_function<T(Args..., ...)const volatile> : public true_type {};

template <typename T, typename... Args>
struct is_function<T(Args..., ...)&> : public true_type {};

template <typename T, typename... Args>
struct is_function<T(Args..., ...)const &> : public true_type {};

template <typename T, typename... Args>
struct is_function<T(Args..., ...)volatile &> : public true_type {};

template <typename T, typename... Args>
struct is_function<T(Args..., ...)const volatile &> : public true_type {};

template <typename T, typename... Args>
struct is_function<T(Args..., ...) && > : public true_type {};

template <typename T, typename... Args>
struct is_function<T(Args..., ...)const &&> : public true_type {};

template <typename T, typename... Args>
struct is_function<T(Args..., ...)volatile &&> : public true_type {};

template <typename T, typename... Args>
struct is_function<T(Args..., ...)const volatile &&> : public true_type {};


template <typename T>
struct is_pointer_helper : public false_type {};

template <typename T>
struct is_pointer_helper<T*> : public true_type {};

template <typename T>
struct _remove_const_volatile_ { typedef T type; };

template <typename T>
struct _remove_const_volatile_<const volatile T> { typedef T type; };

template <typename T>
struct is_pointer : is_pointer_helper<typename _remove_const_volatile_<T>::type> {};


template <typename T>
struct is_lvalue_reference : public false_type {};

template <typename T>
struct is_lvalue_reference<T&> : public true_type {};


template <typename T>
struct is_rvalue_reference : public false_type {};

template <typename T>
struct is_rvalue_reference<T&&> : public true_type {};

template< class T >
struct _is_member_function_pointer_ : public false_type {};

template< class T, class U>
struct _is_member_function_pointer_<T U::*> : public is_function<T> {};

template< class T >
struct is_member_function_pointer : public _is_member_function_pointer_<typename _remove_const_volatile_<T>::type> {};

template <typename T>
struct _is_member_pointer_ : public false_type {};

template <typename T, typename U>
struct _is_member_pointer_<T U::*> : public true_type {};

template <typename T>
struct _is_member_pointer : public _is_member_pointer_<typename _remove_const_volatile_<T>::type> {};

template <typename T>
struct is_member_object_pointer : public bool_constant<_is_member_pointer<T>::value && !is_member_function_pointer<T>::value> {};

}

//----------------------------------------------------------
// composite type categories
//----------------------------------------------------------

namespace {

template <typename T>
struct is_member_pointer : public _is_member_pointer<T> {};

template <typename T>
struct is_arithmetic : public bool_constant<is_integral<T>::value || is_floating_point<T>::value> {};

template <typename T>
struct is_fundamental : public bool_constant<is_arithmetic<T>::value || is_void<T>::value || is_null_pointer<typename _remove_const_volatile_<T>::type>::value> {};

template <typename T>
struct is_scalar : public bool_constant<is_arithmetic<T>::value || is_enum<T>::value || is_pointer<T>::value || is_member_pointer<T>::value || is_null_pointer<T>::value> {};

template <typename T>
struct is_object : public bool_constant<is_scalar<T>::value || is_array<T>::value || is_union<T>::value || is_class<T>::value> {};

template <typename T>
struct is_compound : public bool_constant<!is_fundamental<T>::value> {};

template <typename T>
struct is_reference : public false_type {};

template <typename T>
struct is_reference<T&> : public true_type {};

template <typename T>
struct is_reference<T&&> : public true_type {};

}

//----------------------------------------------------------
// type properties
//----------------------------------------------------------

namespace {

template <typename T>
struct is_const : public false_type {};

template <typename T>
struct is_const<const T> : public true_type {};

template <typename T>
struct is_volatile : public false_type {};

template <typename T>
struct is_volatile<volatile T> : public true_type {};

template <typename T>
struct is_trivial :public  bool_constant<__is_trivial(T)> {};

template <typename T>
struct is_trivially_copyable : public bool_constant<__is_trivially_copyable(T)> {};

template <typename T>
struct is_standard_layout : public bool_constant<__is_standard_layout(T)> {};

template <typename T>
struct is_pod : public bool_constant<__is_pod(T)> {};

template <typename T>
struct is_literal_type : public bool_constant<__is_literal_type(T)> {};

template <typename T>
struct is_empty : public bool_constant<__is_empty(T)> {};

template <typename T>
struct is_polymorphic : public bool_constant<__is_polymorphic(T)> {};

template <typename T>
struct is_final : public bool_constant<__is_final(T)> {};

template <typename T>
struct is_abstract : public bool_constant<__is_abstract(T)> {};

template <typename T, bool = is_arithmetic<T>::value>
struct is_signed : public bool_constant<(T(-1) < T(0)) > {};

template <typename T>
struct is_signed<T, false> : public false_type {};

template <typename T, bool = is_arithmetic<T>::value>
struct is_unsigned : public bool_constant<(T(-1) > T(0))> {};

template <typename T>
struct is_unsigned<T, false> : public false_type {};

}

//----------------------------------------------------------
// supported operations
//----------------------------------------------------------

namespace {

template <typename T, typename... Args>
struct is_constructible : public bool_constant<__is_constructible(T, Args...)> {};

template <typename T, typename... Args>
struct is_trivially_constructible : public bool_constant<__is_trivially_constructible(T, Args...)> {};

template <typename T, typename... Args>
struct is_nothrow_constructible : public bool_constant<__is_nothrow_constructible(T, Args...)> {};

template <typename T>
struct is_default_constructible : public is_constructible<T> {};

template <typename T>
struct is_trivially_default_constructible : public is_trivially_constructible<T> {};

template <typename T>
struct is_nothrow_default_constructible : public is_nothrow_constructible<T> {};

template <typename T>
struct add_lvalue_reference;

template <typename T>
struct add_rvalue_reference;

template <typename T>
struct add_const;

template <typename T>
struct is_copy_constructible : public is_constructible<T, typename add_lvalue_reference<typename add_const<T>::type>::type> {};

template <typename T>
struct is_trivially_copy_constructible : public is_trivially_constructible<T, typename add_lvalue_reference<typename add_const<T>::type>::type> {};

template <typename T>
struct is_nothrow_copy_constructible : public is_nothrow_constructible<T, typename add_lvalue_reference<typename add_const<T>::type>::type> {};

template <typename T>
struct is_move_constructible : public is_constructible<T, typename add_rvalue_reference<T>::type> {};

template <typename T>
struct is_trivially_move_constructible : public is_trivially_constructible<T, typename add_rvalue_reference<T>::type> {};

template <typename T>
struct is_nothrow_move_constructible : public is_nothrow_constructible<T, typename add_rvalue_reference<T>::type> {};

template <typename To, typename From>
struct _is_assignable {
	template <typename Dest, typename Src>
	static auto _function(int) -> decltype((void)(declval<Dest>() = declval<Src>()), true_type());

	template <typename Dest, typename Src>
	static auto _function(...) -> decltype(false_type());

	typedef decltype(_function<To, From>(0)) type;
};

template <typename To, typename From>
struct is_assignable : public _is_assignable<To, From> {};

template <typename To, typename From>
struct is_trivially_assignable : public bool_constant<__is_trivially_assignable(To, From)> {};

template <typename To, typename From>
struct is_nothrow_assignable : public bool_constant<__is_nothrow_assignable(To, From)> {};

template <typename To, typename From>
struct is_copy_assignable : public is_assignable<typename add_lvalue_reference<To>::type, typename add_const<typename add_lvalue_reference<From>::type>::type> {};

template <typename T>
struct is_trivially_copy_assignable : public is_trivially_assignable<typename add_lvalue_reference<T>::type, typename add_const<typename add_lvalue_reference<T>::type>::type> {};

template <typename T>
struct is_nothrow_copy_assignable : public is_nothrow_assignable<typename add_lvalue_reference<T>::type, typename add_const<typename add_lvalue_reference<T>::type>::type> {};

template <typename To, typename From>
struct is_move_assignable : public is_assignable<To, typename add_rvalue_reference<From>::type> {};

template <typename T>
struct is_trivially_move_assignable : public is_trivially_assignable<typename add_lvalue_reference<T>::type, typename add_rvalue_reference<T>::type> {};

template <typename T>
struct is_nothrow_move_assignable :public is_nothrow_constructible<typename add_lvalue_reference<T>::type, typename add_rvalue_reference<T>::type> {};

template <typename T>
struct is_destructible : public bool_constant<__is_destructible(T)> {};

template <typename T>
struct is_trivially_destructible : public bool_constant<__has_trivial_destructor(T)> {};

template <typename T>
struct is_nothrow_destructible :public bool_constant<__is_nothrow_destructible(T)> {};

template <typename T>
struct has_virtual_destructor : public bool_constant<__has_virtual_destructor(T)> {};

}

//----------------------------------------------------------
// property queries
//----------------------------------------------------------

namespace {}

//----------------------------------------------------------
// type relationships
//----------------------------------------------------------

namespace {

template <typename T, typename U>
struct is_same : public false_type {};

template <typename T>
struct is_same<T, T> : public true_type {};

template <typename Base, typename Derived>
struct is_base_of : public bool_constant<__is_base_of(Base, Derived)> {};

template <typename From, typename To, bool b = is_void<From>::value || is_function<To>::value || is_array<To>::value>
struct is_convertible_basic_implementation : public is_void<To> {};

template<typename From, typename To>
class is_convertible_basic_implementation_helper {
	typedef char one;
	typedef short two;

	template <typename T>
	static void test_aux(T);

	template<typename T, typename U>
	static decltype(test_aux<U>(declval<T>()), one()) test(int);

	template<typename, typename>
	static two test(...);

public:
	static const bool value = sizeof(test<From, To>(0)) == 1;
};

template <typename From, typename To>
struct is_convertible_basic_implementation<From, To, false> :public  bool_constant<is_convertible_basic_implementation_helper<From, To>::value> {};

template <typename From, typename To>
struct is_convertible : public is_convertible_basic_implementation<From, To> {};

}

}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Type Modifications
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

namespace {

//----------------------------------------------------------
// Const-volatility specifiers
//----------------------------------------------------------

namespace {

template <typename T>
struct remove_const { typedef T type; };

template <typename T>
struct remove_const<const T> { typedef T type; };

template <typename T>
struct remove_volatile { typedef T type; };

template <typename T>
struct remove_volatile<volatile T> { typedef T type; };

template <typename T>
struct remove_const_volatile { typedef typename remove_const<typename remove_volatile<T>::type>::type type; };

template <typename T>
struct add_const { typedef const T type; };

template <typename T>
struct add_volatile { typedef volatile T type; };

template <typename T>
struct add_const_volatile { typedef typename add_const<typename add_volatile<T>::type>::type type; };

}

//----------------------------------------------------------
// References
//----------------------------------------------------------

namespace {

template <typename T>
struct remove_reference { typedef T type; };

template <typename T>
struct remove_reference<T&> { typedef T type; };

template <typename T>
struct remove_reference<T&&> { typedef T type; };

template <typename T>
struct add_lvalue_reference { typedef T& type; };

template <typename T>
struct add_rvalue_reference { typedef T&& type; };

}

//----------------------------------------------------------
// Pointers
//----------------------------------------------------------

namespace {

template <typename T>
struct remove_pointer { typedef T type; };

template <typename T>
struct remove_pointer<T*> { typedef T type; };

template <typename T>
struct remove_pointer<T* const> { typedef T type; };

template <typename T>
struct remove_pointer<T* volatile> { typedef T type; };

template <typename T>
struct remove_pointer<T* const volatile> { typedef T type; };

template <typename T>
using remove_pointer_type = typename remove_pointer<T>::type;

template <typename T, bool is_function_type = false>
struct _add_pointer { typedef typename remove_reference<T>::type* type; };

template <typename T>
struct _add_pointer<T, true> { typedef T type; };

template <typename T, typename... Args>
struct _add_pointer<T(Args...), true> { using type = T(*)(Args...); };

template <typename T, typename... Args>
struct _add_pointer<T(Args..., ...), true> { using type = T(*)(Args..., ...); };

template <typename T>
struct add_pointer : _add_pointer<T, is_function<T>::value> {};

template <typename T>
using add_pointer_type = typename add_pointer<T>::type;

}

//----------------------------------------------------------
// Sign modifiers
//----------------------------------------------------------

namespace {

template <typename T>
struct make_unsigned {};

template <>
struct make_unsigned<char> { typedef unsigned char type; };

template <>
struct make_unsigned<short> { typedef unsigned short type; };

template <>
struct make_unsigned<int> { typedef unsigned int type; };

template <>
struct make_unsigned<long> { typedef unsigned long type; };

template <>
struct make_unsigned<long long> { typedef unsigned long long type; };

template <typename T>
struct make_signed {};

template <>
struct make_unsigned<unsigned char> { typedef char type; };

template <>
struct make_unsigned<unsigned short> { typedef short type; };

template <>
struct make_unsigned<unsigned int> { typedef int type; };

template <>
struct make_unsigned<unsigned long> { typedef long type; };

template <>
struct make_unsigned<unsigned long long> { typedef long long type; };

}

//----------------------------------------------------------
// Arrays
//----------------------------------------------------------

namespace {

template <typename T>
struct remove_extent { typedef T type; };

template <typename T>
struct remove_extent<T[]> { typedef T type; };

template <typename T, size_type N>
struct remove_extent<T[N]> { typedef T type; };

template <typename T>
using remove_extent_type = typename remove_extent<T>::type;

template <typename T>
struct remove_all_extents { typedef T type; };

template <typename T>
struct remove_all_extents<T[]> { typedef typename remove_all_extents<T>::type type; };

template <typename T, size_type N>
struct remove_all_extents<T[N]> { typedef typename remove_all_extents<T>::type type; };

template <typename T>
using remove_all_extents_type = typename remove_all_extents<T>::type;

}

}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Miscellaneous Transformations
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

namespace {

template <size_type Len, size_type Align>
struct aligned_storage { typedef struct { alignas(Align) unsigned char data[Len]; } type; };

template <typename T, typename... Rest>
struct max_sizeof { enum { value = max(sizeof(T), max_sizeof<Rest...>::value) }; };

template <size_type Len, typename... Types>
struct aligned_union {
	static constexpr size_type alignment_value = max({ alignof(Types)... });
	static constexpr size_type length = Len;
	struct type { alignas(alignment_value) char _s[max<size_type>(length, static_cast<size_type>(max_sizeof<Types...>::value))]; };
};

template <bool B, typename T, typename U>
struct conditional;

template <typename T>
struct decay {
private:
	typedef typename remove_reference<T>::type U;
public:
	typedef typename conditional<
		is_array<U>::value,
		add_pointer_type<remove_extent_type<U>>,
		typename conditional<
		is_function<U>::value,
		add_pointer_type<U>,
		typename remove_const_volatile<U>::type
		>::type
	>::type type;
};

template <typename T>
using decay_type = typename decay<T>::type;

template <bool B, typename T = void>
struct enable_if {};

template <typename T>
struct enable_if<true, T> { typedef T type; };

template <bool B, typename T = void>
using enable_if_type = typename enable_if<B, T>::type;

template <bool B, typename T, typename U>
struct conditional { typedef T type; };

template <typename T, typename U>
struct conditional<false, T, U> { typedef U type; };

template <bool B, typename T, typename U>
using conditional_type = typename conditional<B, T, U>::type;

template <typename... T>
struct common_type;

template <typename T>
struct common_type<T> { typedef decay_type<T> type; };

template <typename T, typename U>
struct common_type<T, U> { typedef decay_type<decltype(true ? declval<T>() : declval<U>())> type; };

template <typename T, typename U, typename... V>
struct common_type<T, U, V...> { typedef typename common_type<typename common_type<T, U>::type, V...>::type type; };

template <typename... T>
using common_type_type = typename common_type<T...>::type;

}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Operations on Traits
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

namespace {}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Non-standard
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

template <typename T>
struct __is_iterator {
	template <typename U>
	static auto _function(int) -> decltype(declval<U>().iterator_category, true_type());

	template <typename U>
	static auto _function(...) -> decltype(false_type());

	typedef decltype(_function<T>(0)) type;
};

template <typename T>
struct is_iterator : __is_iterator<T>::type {};


template<size_type N>
struct is_binary_power { enum { value = N & !(N & (N - 1)) }; };


enum class __system_architecture__ {
	k8 = 8,
	k16 = 16,
	k32 = 32,
	k64 = 64,
	k128 = 128
};

template <int>
inline const __system_architecture__ system_architecture();

template <>
inline const __system_architecture__ system_architecture<1>() { return __system_architecture__::k8; }

template <>
inline const __system_architecture__ system_architecture<2>() { return __system_architecture__::k16; }

template <>
inline const __system_architecture__ system_architecture<4>() { return __system_architecture__::k32; }

template <>
inline const __system_architecture__ system_architecture<8>() { return __system_architecture__::k64; }

template <>
inline const __system_architecture__ system_architecture<16>() { return __system_architecture__::k128; }

template <typename Iterator, typename = enable_if_type<is_iterator<Iterator>::value>>
struct iterator_traits {
	typedef typename remove_reference<typename remove_const_volatile<typename Iterator::type>::type>::type type;

	typedef typename type value_type;
	typedef typename type& reference_type;
	typedef const typename type& const_reference_type;
};

template <typename Char = char, typename Int = int, typename = enable_if_type<is_integral<Int>::value>>
struct char_traits {

	typedef Char char_type;

	typedef Int int_type;

	static void assign(char_type& r, const char_type& a) noexcept { r = a; }

	static char_type* assign(char_type* p, size_type count, char_type a) noexcept {
		for (type_traits<size_type>::value_type i = 0; i < count; ++i) {
			p[i] = a;
		}
		return p;
	}

	static constexpr bool eq(char_type a, char_type b) noexcept { return a == b; }

	static constexpr bool lt(char_type a, char_type b) noexcept { return a < b; }

	static char_type* move(char_type* dest, const char_type* src, size_type count) noexcept {
		if (src < dest && dest < src + count) {
			auto next = dest;
			next += count;
			src += count;
			for (type_traits<size_type>::value_type i = 0; i < count; ++i) {
				assign(*--next, *--src);
			}
		} else {
			return copy(dest, src, count);
		}
	}

	static char_type* copy(char_type* dest, const char_type* src, size_type count) noexcept {
		for (type_traits<size_type>::value_type i = 0; i < count; ++i) {
			assign(dest[i], src[i]);
		}
		return dest;
	}

	static int compare(const char_type* a, const char_type* b, size_type count) noexcept {
		for (type_traits<size_type>::value_type i = 0; i < count; ++i) {
			if (!eq(a[i], b[i])) {
				if (lt(a[i], b[i])) {
					return -1;
				}
				return 1;
			}
		}
		return 0;
	}

	static size_type length(const char_type* ptr) noexcept {
		type_traits<size_type>::value_type count = 0;
		while (!eq(Char(), *ptr++)) count++;
		return count;
	}

	static const char_type* find(const char_type* ptr, size_type count, const char_type& ch) noexcept {
		for (type_traits<size_type>::value_type i = 0; i < count; ++i) {
			if (eq(ptr[i], ch)) {
				return &ptr[i];
			}
		}

		SI_MULTIPLES(m);

		double x = 3_mm;

		return nullptr;
	}

	static constexpr char_type to_char_type(int_type i) noexcept { return i; }

	static constexpr int_type to_int_type(char_type c) noexcept { return c; }

	static constexpr bool eq_int_type(int_type a, int_type b) noexcept { return a == b; }

	static constexpr int_type eof() noexcept {
#ifndef EOF
#define EOF (-1)
#endif
		return EOF;
	}

	static constexpr int_type not_eof(int_type i) noexcept { return (i == eof() ? eof() : i); }
};

}

}
