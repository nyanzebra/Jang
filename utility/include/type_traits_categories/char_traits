#pragma once 

#include "../types"

namespace jang {

template <typename Char = char,	typename Int = int>
class char_traits {
public:
	typedef Char char_type;
	typedef Int int_type;
protected:
private:
public:

	static void assign(char_type& r, const char_type& a) noexcept { r = a; }

	static char_type* assign(char_type* p, size_type count, char_type a) noexcept {
		for (size_type i = 0; i < count; ++i) {
			p[i] = a;
		}
		return p;
	}

	static constexpr bool equal(char_type a, char_type b) noexcept { return a == b; }

	static constexpr bool less_than(char_type a, char_type b) noexcept { return a < b; }

	static char_type* move(char_type* dest, const char_type* src, size_type count) noexcept {
		if (src < dest && dest < src + count) {
			auto next = dest;
			next += count;
			src += count;
			for (size_type i = 0; i < count; ++i) {
				assign(*--next, *--src);
			}
		} else {
			return copy(dest, src, count);
		}
	}

	static char_type* copy(char_type* dest, const char_type* src, size_type count) noexcept {
		for (size_type i = 0; i < count; ++i) {
			assign(dest[i], src[i]);
		}
		return dest;
	}

	static int compare(const char_type* a, const char_type* b, size_type count) noexcept {
		for (size_type i = 0; i < count; ++i) {
			if (!eq(a[i], b[i])) {
				if (lt(a[i], b[i])) {
					return -1;
				}
				return 1;
			}
		}
		return 0;
	}

	static size_type length(const char_type* ptr) noexcept {
		size_type count = 0;
		while (!eq(Char(), *ptr++)) count++;
		return count;
	}

	static const char_type* find(const char_type* ptr, size_type count, const char_type& ch) noexcept {
		for (size_type i = 0; i < count; ++i) {
			if (eq(ptr[i], ch)) {
				return &ptr[i];
			}
		}

		return nullptr;
	}

	static constexpr char_type to_char_type(int_type i) noexcept { return i; }

	static constexpr int_type to_int_type(char_type c) noexcept { return c; }

	static constexpr bool equal_int_type(int_type a, int_type b) noexcept { return a == b; }

	static constexpr int_type end_of_file() noexcept {
#ifndef EOF
#define EOF (-1)
#endif
		return EOF;
	}

	static constexpr int_type not_end_of_file(int_type i) noexcept { return (i == end_of_file() ? end_of_file() : i); }
protected:
private:
};

}
