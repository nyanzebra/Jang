#pragma once

#include "../type_categories/base_types"
#include "../type_categories/fundamental_constant_types"
#include "const_volatility_specifiers"

namespace jang {

template <typename T>
struct is_void : public false_type {};

template <>
struct is_void<void> : public true_type {};

template <typename T>
constexpr bool is_void_value = is_void_value<T>;

template <typename T>
struct is_null_pointer : public false_type {};

template <>
struct is_null_pointer<nullptr_type> : public true_type {};

template <typename T>
constexpr bool is_null_pointer_value = is_null_pointer_value<T>;

template <typename T>
struct is_integral : public false_type {};

template <>
struct is_integral<bool> : public true_type {};

template <>
struct is_integral<char> : public true_type {};

template <>
struct is_integral<char16_t> : public true_type {};

template <>
struct is_integral<char32_t> : public true_type {};

template <>
struct is_integral<wchar_t> : public true_type {};

template <>
struct is_integral<short> : public true_type {};

template <>
struct is_integral<int> : public true_type {};

template <>
struct is_integral<long> : public true_type {};

template <>
struct is_integral<long long> : public true_type {};

template <typename T>
constexpr bool is_integral_value = is_integral<T>::value;

template <typename T>
struct is_floating_point : public false_type {};

template <>
struct is_floating_point<float> : public true_type {};

template <>
struct is_floating_point<double> : public true_type {};

template <>
struct is_floating_point<long double> : public true_type {};

template <typename T>
constexpr bool is_floating_point_value = is_floating_point<T>::value;

template <typename T>
struct is_array : public false_type {};

template <typename T>
struct is_array<T[]> : public true_type {};

template <typename T, size_type N>
struct is_array<T[N]> : public true_type {};

template <typename T>
constexpr bool is_array_value = is_array<T>::value;

template <typename T>
struct is_enum : public bool_constant<__is_enum(T)> {};

template <typename T>
constexpr bool is_enum_value = is_enum<T>::value;

template <typename T>
struct is_union : public bool_constant<__is_union(T)> {};

template <typename T>
constexpr bool is_union_value = is_union<T>::value;

template <typename T>
struct is_class : public bool_constant<__is_class(T)> {};

template <typename T>
constexpr bool is_class_value = is_class<T>::value;

template <typename T>
struct is_function : public false_type {};

template <typename T, typename... Args>
struct is_function<T(Args...)> : public true_type {};

template <typename T, typename... Args>
struct is_function<T(Args...)const> : public true_type {};

template <typename T, typename... Args>
struct is_function<T(Args...)volatile> : public true_type {};

template <typename T, typename... Args>
struct is_function<T(Args...)const volatile> : public true_type {};

template <typename T, typename... Args>
struct is_function<T(Args...)&> : public true_type {};

template <typename T, typename... Args>
struct is_function<T(Args...)const &> : public true_type {};

template <typename T, typename... Args>
struct is_function<T(Args...)volatile &> : public true_type {};

template <typename T, typename... Args>
struct is_function<T(Args...)const volatile &> : public true_type {};

template <typename T, typename... Args>
struct is_function<T(Args...) && > : public true_type {};

template <typename T, typename... Args>
struct is_function<T(Args...)const &&> : public true_type {};

template <typename T, typename... Args>
struct is_function<T(Args...)volatile &&> : public true_type {};

template <typename T, typename... Args>
struct is_function<T(Args...)const volatile &&> : public true_type {};

template <typename T, typename... Args>
struct is_function<T(Args..., ...)> : public true_type {};

template <typename T, typename... Args>
struct is_function<T(Args..., ...)const> : public true_type {};

template <typename T, typename... Args>
struct is_function<T(Args..., ...)volatile> : public true_type {};

template <typename T, typename... Args>
struct is_function<T(Args..., ...)const volatile> : public true_type {};

template <typename T, typename... Args>
struct is_function<T(Args..., ...)&> : public true_type {};

template <typename T, typename... Args>
struct is_function<T(Args..., ...)const &> : public true_type {};

template <typename T, typename... Args>
struct is_function<T(Args..., ...)volatile &> : public true_type {};

template <typename T, typename... Args>
struct is_function<T(Args..., ...)const volatile &> : public true_type {};

template <typename T, typename... Args>
struct is_function<T(Args..., ...) && > : public true_type {};

template <typename T, typename... Args>
struct is_function<T(Args..., ...)const &&> : public true_type {};

template <typename T, typename... Args>
struct is_function<T(Args..., ...)volatile &&> : public true_type {};

template <typename T, typename... Args>
struct is_function<T(Args..., ...)const volatile &&> : public true_type {};

template <typename T>
constexpr bool is_function_value = is_function<T>::value;

namespace implementation {

template <typename T>
struct is_pointer : public false_type {};

template <typename T>
struct is_pointer<T*> : public true_type {};

}

template <typename T>
struct is_pointer : public implementation::is_pointer<remove_const_volatile_type<T>> {};

template <typename T>
constexpr bool is_pointer_value = is_pointer<T>::value;

template <typename T>
struct is_lvalue_reference : public false_type {};

template <typename T>
struct is_lvalue_reference<T&> : public true_type {};

template <typename T>
constexpr bool is_lvalue_reference_value = is_lvalue_reference<T>::value;

template <typename T>
struct is_rvalue_reference : public false_type {};

template <typename T>
struct is_rvalue_reference<T&&> : public true_type {};

template <typename T>
constexpr bool is_rvalue_reference_value = is_rvalue_reference<T>::value;

namespace implementation {

template <typename T>
struct is_member_function_pointer : public false_type {};

template <typename T, typename U>
struct is_member_function_pointer<T U::*> : public is_function<T> {};

}

template <typename T>
struct is_member_function_pointer : public implementation::is_member_function_pointer<typename remove_const_volatile<T>::type> {};

template <typename T>
constexpr bool is_member_function_pointer_value = is_member_function_pointer<T>::value;

namespace implementation {

template <typename T>
struct is_member_pointer : public false_type {};

template <typename T, typename U>
struct is_member_pointer<T U::*> : public true_type {};

}

template <typename T>
struct is_member_object_pointer : public bool_constant<implementation::is_member_pointer<remove_const_volatile_type<T>>::value && !is_member_function_pointer<T>::value> {};

template <typename T>
constexpr bool is_member_object_pointer_value = is_member_object_pointer<T>::value;

}
