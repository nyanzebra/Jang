#pragma once

#include "type_traits"
#include "limits"
#include "new"
#include "utility"

namespace jang {

template <typename T>
class allocator_policy {
public:
protected:
private:
public:
	allocator_policy() {}
	allocator_policy(const allocator_policy&) {}
	template <typename U>
	allocator_policy(const allocator_policy<U>&) {}
	allocator_policy(allocator_policy&&) {}
	~allocator_policy() {}

	T* address(T& value) const noexcept { return &value; }

	const T* address(const T& value) const noexcept { return &value; }

	virtual T* allocate(size_type size, const_void_pointer_type hint = 0) = 0;

	virtual void deallocate(T* pointer, size_type size) = 0;

	virtual const size_type max_size() const = 0;

protected:
private:
};

template <typename T>
class dummy_allocator_policy : public allocator_policy<T> {
public:
protected:
private:
public:
	dummy_allocator_policy() {}
	dummy_allocator_policy(const dummy_allocator_policy&) {}
	template <typename U>
	dummy_allocator_policy(const dummy_allocator_policy<U>&) noexcept {}
	dummy_allocator_policy(dummy_allocator_policy&&) {}
	~dummy_allocator_policy() {}

	T* allocate(size_type size, const_void_pointer_type hint = 0) override { return nullptr; }

	void deallocate(T* pointer, size_type size) override {}

	template <typename Arg, typename... Args, typename = enable_if_type<is_pointer<Arg>::value && is_move_assignable<Args...>::value>>
	void construct(Arg pointer, Args&&... args) {}

	void destroy(T* pointer) {}

	const size_type max_size() const noexcept override { return size_type(-1); }
protected:
private:
};

template <typename T>
class aligned_allocator_policy : public allocator_policy<T> {
public:
protected:
private:
public:
	aligned_allocator_policy() = default;
	aligned_allocator_policy(const aligned_allocator_policy&) = default;
	template <typename U>
	aligned_allocator_policy(const aligned_allocator_policy<U>&) noexcept {}
	aligned_allocator_policy(aligned_allocator_policy&&) = default;
	virtual ~aligned_allocator_policy() = default;

	T* allocate(size_type size, const_void_pointer_type hint = 0) override {
		if (!size) {
			return nullptr;
		}

		if (max_size() < size) {
			throw bad_alloc();
		}

		void_pointer_type ptr = ::operator new<T>(size, aligned_type());
		return reinterpret_cast<T*>(ptr);
	}

	void deallocate(T* pointer, size_type size) override {
		if (max_size() < size) {
			throw bad_alloc();
		}

		::operator delete(pointer, aligned_type());
	}

	template <typename Arg, typename... Args, typename = enable_if_type<is_pointer<Arg>::value && is_move_assignable<Args...>::value>>
	void construct(Arg pointer, Args&&... args) { ::new((void_pointer_type)pointer) Arg(forward<Args>(args)...); }

	void destroy(T* pointer) { pointer->~T(); }

	const size_type max_size() const noexcept override { return ((size_type)(-1) / sizeof(T)); }

protected:

private:

};

template <typename T>
using standard_based_allocator_policy = aligned_allocator_policy<T>;

template <typename T, size_type Size, size_type Alignment = alignof(max_align_type)>
class stack_based_allocator_policy : public allocator_policy<T> {
public:
	static_assert(sizeof(T) <= Alignment, "Alignment of memory must be at least the size of the type...");
	static_assert(Size > 0, "Cannot allocate zero-sized memory...");
protected:
private:
	bool _is_allocated;
	size_type _required_size = sizeof(T);
	arithmetic_pointer_type _pointer;
	alignas(Alignment) char _buffer[Size];
public:
	stack_based_allocator_policy() noexcept : _pointer(_buffer) {}
	stack_based_allocator_policy(const stack_based_allocator_policy&) = default;
	template <typename U, size_type V, size_type W = alignof(max_align_type)>
	stack_based_allocator_policy(const stack_based_allocator_policy<U, V, W>&) noexcept {}
	stack_based_allocator_policy(stack_based_allocator_policy&&) = default;
	~stack_based_allocator_policy() { _pointer = nullptr; }

	T* allocate(size_type size, const_void_pointer_type hint = 0) override {
		assert(_buffer <= _pointer && _pointer <= _buffer + Size);

		unsigned_int_pointer_type aligned_difference = (size + (Alignment - 1)) & ~(Alignment - 1);

		if (static_cast<unsigned_int_pointer_type>(_buffer + Size - _pointer) >= aligned_difference) {
			void_pointer_type result = _pointer;
			_pointer += aligned_difference;
			return result;
		}

		static_assert(Alignment <= alignof(max_align_type), "operator new cannot guarantee behaviour of an alignment larger than the alignof(max_align_type)");
		return ::operator new(size);
	}

	void deallocate(T* pointer, size_type size) override {
		assert(_buffer <= _pointer && _pointer <= _buffer + Size);

		if (_buffer <= pointer && pointer <= _buffer + Size) {
			size = (size + (Alignment - 1)) & ~(Alignment - 1);
			if (pointer + size == _pointer) {
				_pointer = pointer;
			}
		} else {
			::operator delete(pointer);
		}
	}

	template <typename U, typename... Args, typename = enable_if_type<is_pointer<U>::value && is_move_assignable<Args...>::value>>
	void construct(U pointer, Args... args) { new (pointer) U(forward<Args>(args)...); }

	void destroy(T* pointer) { pointer->~T(); }

	const size_type max_size() const noexcept override { return Size; }
protected:
private:
};

template <typename T, size_type Size>
class pool_based_allocator_policy : public allocator_policy<T> {
public:
	static_assert(Size > 0, "Cannot allocate zero-sized memory...");
protected:
private:
	alignas(T) T _buffer[Size];
	bool _free_buffer[Size];
	arithmetic_pointer_type _pointer;
	pointer_difference_type _difference = alignof(T); 
public:
	pool_based_allocator_policy() noexcept : _pointer(_buffer) {
		for (auto i = 0; i < Size; ++i) {
			_free_buffer[i] = true;
		}
	}
	pool_based_allocator_policy(const pool_based_allocator_policy&) = default;
	template <typename U, size_type V>
	pool_based_allocator_policy(const pool_based_allocator_policy<U, V>&) noexcept {}
	pool_based_allocator_policy(pool_based_allocator_policy&&) = default;
	~pool_based_allocator_policy() { _pointer = nullptr; }

	T* allocate(size_type size, const_void_pointer_type hint = 0) override {
		//assert(_buffer <= _pointer && _pointer <= _buffer + Size, "Trying to allocate beyond memory range");
		//assert(_pointer + size <= _buffer + Size, "Trying to allocate beyond memory range");

		size_type index = (_pointer - _buffer) / sizeof(T);
		size_type iterations = 0;

		while (!_free_buffer[index] && iterations < Size) {
			iterations++;
			index = (index + 1) % Size;
		}

		if (iterations < Size && index + size < _buffer + Size) {
			bool can_fit = true;
			for (auto i = index; i < size; ++i) {
				if (!_free_buffer[i]) {
					can_fit = false;
				}
			}

			if (can_fit) {
				for (auto i = index; i < size; ++i) {
					_free_buffer[i] = false;
				}
				_pointer = _buffer[index + size];
				return _buffer[index];			
			}
		}

		return ::operator new(size);
	}

	void deallocate(T* pointer, size_type size) override {
		assert(_buffer <= _pointer && _pointer <= _buffer + Size);

		if (_buffer <= pointer && pointer <= _buffer + Size) {
			if (pointer + (size * sizeof(T)) == _pointer) {
				for (auto i = (pointer - _buffer) / sizeof(T); i < size; ++i) {
					_free_buffer[i] = true;
				}
				_pointer = pointer;
			}
		} else {
			::operator delete(pointer);
		}
	}

	template <typename U, typename... Args, typename = enable_if_type<is_pointer<U>::value && is_move_assignable<Args...>::value>>
	void construct(U pointer, Args... args) { new (pointer) U(forward<Args>(args)...); }

	void destroy(T* pointer) { pointer->~T(); }

	const size_type max_size() const noexcept override { return Size; }
protected:
private:
};



template <typename T, size_type size>
class single_frame_based_allocator_policy : public allocator_policy<T> {
public:

protected:

private:

public:

protected:

private:

};

template <typename T, size_type size>
class double_frame_based_allocator_policy : public allocator_policy<T> {
public:

protected:

private:

public:

protected:

private:

};

template <typename T, typename Policy = standard_based_allocator_policy<T>>
class allocator : public Policy {
public:
	typedef T type;
	typedef Policy policy_type;
protected:
private:
public:
	static_assert(!is_const<T>::value, "The C++ Standard forbids containers of const elements because allocator<const T> is ill-formed.");

	allocator() = default;
	allocator(const allocator&) = default;
	template <typename U>
	allocator(const allocator<U>&) {}
	allocator(allocator&&) = default;
	~allocator() = default;

	allocator& operator=(const allocator&) = default;
	allocator& operator=(allocator&&) = default;

	template <typename U>
	struct rebind { typedef allocator<U> other; };

	T* address(T& value) const noexcept { return policy_type::address(value); }

	const T* address(const T& value) const noexcept { return policy_type::address(value); }

	T* allocate(size_type size, const_void_pointer_type hint = 0) { return policy_type::allocate(size, hint); }

	void deallocate(T* pointer, size_type size) { policy_type::deallocate(pointer, size); }

	template <typename Arg, typename... Args, typename = enable_if_type<is_pointer<Arg>::value && is_move_assignable<Args...>::value>>
	void construct(Arg pointer, Args... args) { policy_type::construct(pointer, forward<Args>(args)...); }

	template <typename Arg, typename = enable_if_type<is_pointer<Arg>::value>>
	void destroy(Arg pointer) { policy_type::destroy(pointer); }

	const size_type max_size() const noexcept { return policy_type::max_size(); }

	template <typename A, typename B>
	friend bool operator==(const allocator<A>& a, const allocator<B>& b) { return true; }

	template <typename A, typename B>
	friend bool operator!=(const allocator<A>& a, const allocator<B>& b) { return !(a == b); }
protected:
private:
};

}
